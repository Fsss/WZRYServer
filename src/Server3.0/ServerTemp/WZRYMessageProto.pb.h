// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: WZRYMessageProto.proto

#ifndef PROTOBUF_WZRYMessageProto_2eproto__INCLUDED
#define PROTOBUF_WZRYMessageProto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_WZRYMessageProto_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsCloseRequestImpl();
void InitDefaultsCloseRequest();
void InitDefaultsLoginRequestImpl();
void InitDefaultsLoginRequest();
void InitDefaultsLoginResponseImpl();
void InitDefaultsLoginResponse();
void InitDefaultsRegisterRequestImpl();
void InitDefaultsRegisterRequest();
void InitDefaultsRegisterResponseImpl();
void InitDefaultsRegisterResponse();
void InitDefaultsMatchRequestImpl();
void InitDefaultsMatchRequest();
void InitDefaultsMatchResponseImpl();
void InitDefaultsMatchResponse();
void InitDefaultsChatRequestImpl();
void InitDefaultsChatRequest();
void InitDefaultsChatResponseImpl();
void InitDefaultsChatResponse();
void InitDefaultsSkillRequestImpl();
void InitDefaultsSkillRequest();
void InitDefaultsSkillResponseImpl();
void InitDefaultsSkillResponse();
inline void InitDefaults() {
  InitDefaultsCloseRequest();
  InitDefaultsLoginRequest();
  InitDefaultsLoginResponse();
  InitDefaultsRegisterRequest();
  InitDefaultsRegisterResponse();
  InitDefaultsMatchRequest();
  InitDefaultsMatchResponse();
  InitDefaultsChatRequest();
  InitDefaultsChatResponse();
  InitDefaultsSkillRequest();
  InitDefaultsSkillResponse();
}
}  // namespace protobuf_WZRYMessageProto_2eproto
namespace WZRY {
class ChatRequest;
class ChatRequestDefaultTypeInternal;
extern ChatRequestDefaultTypeInternal _ChatRequest_default_instance_;
class ChatResponse;
class ChatResponseDefaultTypeInternal;
extern ChatResponseDefaultTypeInternal _ChatResponse_default_instance_;
class CloseRequest;
class CloseRequestDefaultTypeInternal;
extern CloseRequestDefaultTypeInternal _CloseRequest_default_instance_;
class LoginRequest;
class LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
class LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class MatchRequest;
class MatchRequestDefaultTypeInternal;
extern MatchRequestDefaultTypeInternal _MatchRequest_default_instance_;
class MatchResponse;
class MatchResponseDefaultTypeInternal;
extern MatchResponseDefaultTypeInternal _MatchResponse_default_instance_;
class RegisterRequest;
class RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class RegisterResponse;
class RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class SkillRequest;
class SkillRequestDefaultTypeInternal;
extern SkillRequestDefaultTypeInternal _SkillRequest_default_instance_;
class SkillResponse;
class SkillResponseDefaultTypeInternal;
extern SkillResponseDefaultTypeInternal _SkillResponse_default_instance_;
}  // namespace WZRY
namespace WZRY {

// ===================================================================

class CloseRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WZRY.CloseRequest) */ {
 public:
  CloseRequest();
  virtual ~CloseRequest();

  CloseRequest(const CloseRequest& from);

  inline CloseRequest& operator=(const CloseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloseRequest(CloseRequest&& from) noexcept
    : CloseRequest() {
    *this = ::std::move(from);
  }

  inline CloseRequest& operator=(CloseRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CloseRequest* internal_default_instance() {
    return reinterpret_cast<const CloseRequest*>(
               &_CloseRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(CloseRequest* other);
  friend void swap(CloseRequest& a, CloseRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloseRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  CloseRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloseRequest& from);
  void MergeFrom(const CloseRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloseRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:WZRY.CloseRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_WZRYMessageProto_2eproto::TableStruct;
  friend void ::protobuf_WZRYMessageProto_2eproto::InitDefaultsCloseRequestImpl();
};
// -------------------------------------------------------------------

class LoginRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WZRY.LoginRequest) */ {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(LoginRequest* other);
  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  LoginRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 2;
  void clear_username();
  static const int kUsernameFieldNumber = 2;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string passwd = 3;
  void clear_passwd();
  static const int kPasswdFieldNumber = 3;
  const ::std::string& passwd() const;
  void set_passwd(const ::std::string& value);
  #if LANG_CXX11
  void set_passwd(::std::string&& value);
  #endif
  void set_passwd(const char* value);
  void set_passwd(const char* value, size_t size);
  ::std::string* mutable_passwd();
  ::std::string* release_passwd();
  void set_allocated_passwd(::std::string* passwd);

  // bool islogin = 1;
  void clear_islogin();
  static const int kIsloginFieldNumber = 1;
  bool islogin() const;
  void set_islogin(bool value);

  // @@protoc_insertion_point(class_scope:WZRY.LoginRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr passwd_;
  bool islogin_;
  mutable int _cached_size_;
  friend struct ::protobuf_WZRYMessageProto_2eproto::TableStruct;
  friend void ::protobuf_WZRYMessageProto_2eproto::InitDefaultsLoginRequestImpl();
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WZRY.LoginResponse) */ {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(LoginResponse* other);
  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  LoginResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // bool issuccess = 1;
  void clear_issuccess();
  static const int kIssuccessFieldNumber = 1;
  bool issuccess() const;
  void set_issuccess(bool value);

  // @@protoc_insertion_point(class_scope:WZRY.LoginResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  bool issuccess_;
  mutable int _cached_size_;
  friend struct ::protobuf_WZRYMessageProto_2eproto::TableStruct;
  friend void ::protobuf_WZRYMessageProto_2eproto::InitDefaultsLoginResponseImpl();
};
// -------------------------------------------------------------------

class RegisterRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WZRY.RegisterRequest) */ {
 public:
  RegisterRequest();
  virtual ~RegisterRequest();

  RegisterRequest(const RegisterRequest& from);

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterRequest(RegisterRequest&& from) noexcept
    : RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(RegisterRequest* other);
  friend void swap(RegisterRequest& a, RegisterRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RegisterRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RegisterRequest& from);
  void MergeFrom(const RegisterRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RegisterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string newusername = 1;
  void clear_newusername();
  static const int kNewusernameFieldNumber = 1;
  const ::std::string& newusername() const;
  void set_newusername(const ::std::string& value);
  #if LANG_CXX11
  void set_newusername(::std::string&& value);
  #endif
  void set_newusername(const char* value);
  void set_newusername(const char* value, size_t size);
  ::std::string* mutable_newusername();
  ::std::string* release_newusername();
  void set_allocated_newusername(::std::string* newusername);

  // string newpasswd = 2;
  void clear_newpasswd();
  static const int kNewpasswdFieldNumber = 2;
  const ::std::string& newpasswd() const;
  void set_newpasswd(const ::std::string& value);
  #if LANG_CXX11
  void set_newpasswd(::std::string&& value);
  #endif
  void set_newpasswd(const char* value);
  void set_newpasswd(const char* value, size_t size);
  ::std::string* mutable_newpasswd();
  ::std::string* release_newpasswd();
  void set_allocated_newpasswd(::std::string* newpasswd);

  // @@protoc_insertion_point(class_scope:WZRY.RegisterRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr newusername_;
  ::google::protobuf::internal::ArenaStringPtr newpasswd_;
  mutable int _cached_size_;
  friend struct ::protobuf_WZRYMessageProto_2eproto::TableStruct;
  friend void ::protobuf_WZRYMessageProto_2eproto::InitDefaultsRegisterRequestImpl();
};
// -------------------------------------------------------------------

class RegisterResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WZRY.RegisterResponse) */ {
 public:
  RegisterResponse();
  virtual ~RegisterResponse();

  RegisterResponse(const RegisterResponse& from);

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterResponse(RegisterResponse&& from) noexcept
    : RegisterResponse() {
    *this = ::std::move(from);
  }

  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
               &_RegisterResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(RegisterResponse* other);
  friend void swap(RegisterResponse& a, RegisterResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RegisterResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RegisterResponse& from);
  void MergeFrom(const RegisterResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RegisterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // bool issuccess = 1;
  void clear_issuccess();
  static const int kIssuccessFieldNumber = 1;
  bool issuccess() const;
  void set_issuccess(bool value);

  // @@protoc_insertion_point(class_scope:WZRY.RegisterResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  bool issuccess_;
  mutable int _cached_size_;
  friend struct ::protobuf_WZRYMessageProto_2eproto::TableStruct;
  friend void ::protobuf_WZRYMessageProto_2eproto::InitDefaultsRegisterResponseImpl();
};
// -------------------------------------------------------------------

class MatchRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WZRY.MatchRequest) */ {
 public:
  MatchRequest();
  virtual ~MatchRequest();

  MatchRequest(const MatchRequest& from);

  inline MatchRequest& operator=(const MatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchRequest(MatchRequest&& from) noexcept
    : MatchRequest() {
    *this = ::std::move(from);
  }

  inline MatchRequest& operator=(MatchRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchRequest* internal_default_instance() {
    return reinterpret_cast<const MatchRequest*>(
               &_MatchRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(MatchRequest* other);
  friend void swap(MatchRequest& a, MatchRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  MatchRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MatchRequest& from);
  void MergeFrom(const MatchRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MatchRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool ismatch = 1;
  void clear_ismatch();
  static const int kIsmatchFieldNumber = 1;
  bool ismatch() const;
  void set_ismatch(bool value);

  // int32 matchtype = 2;
  void clear_matchtype();
  static const int kMatchtypeFieldNumber = 2;
  ::google::protobuf::int32 matchtype() const;
  void set_matchtype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:WZRY.MatchRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool ismatch_;
  ::google::protobuf::int32 matchtype_;
  mutable int _cached_size_;
  friend struct ::protobuf_WZRYMessageProto_2eproto::TableStruct;
  friend void ::protobuf_WZRYMessageProto_2eproto::InitDefaultsMatchRequestImpl();
};
// -------------------------------------------------------------------

class MatchResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WZRY.MatchResponse) */ {
 public:
  MatchResponse();
  virtual ~MatchResponse();

  MatchResponse(const MatchResponse& from);

  inline MatchResponse& operator=(const MatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchResponse(MatchResponse&& from) noexcept
    : MatchResponse() {
    *this = ::std::move(from);
  }

  inline MatchResponse& operator=(MatchResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchResponse* internal_default_instance() {
    return reinterpret_cast<const MatchResponse*>(
               &_MatchResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(MatchResponse* other);
  friend void swap(MatchResponse& a, MatchResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  MatchResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MatchResponse& from);
  void MergeFrom(const MatchResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MatchResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string matchmessage = 2;
  void clear_matchmessage();
  static const int kMatchmessageFieldNumber = 2;
  const ::std::string& matchmessage() const;
  void set_matchmessage(const ::std::string& value);
  #if LANG_CXX11
  void set_matchmessage(::std::string&& value);
  #endif
  void set_matchmessage(const char* value);
  void set_matchmessage(const char* value, size_t size);
  ::std::string* mutable_matchmessage();
  ::std::string* release_matchmessage();
  void set_allocated_matchmessage(::std::string* matchmessage);

  // bool issuccess = 1;
  void clear_issuccess();
  static const int kIssuccessFieldNumber = 1;
  bool issuccess() const;
  void set_issuccess(bool value);

  // @@protoc_insertion_point(class_scope:WZRY.MatchResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr matchmessage_;
  bool issuccess_;
  mutable int _cached_size_;
  friend struct ::protobuf_WZRYMessageProto_2eproto::TableStruct;
  friend void ::protobuf_WZRYMessageProto_2eproto::InitDefaultsMatchResponseImpl();
};
// -------------------------------------------------------------------

class ChatRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WZRY.ChatRequest) */ {
 public:
  ChatRequest();
  virtual ~ChatRequest();

  ChatRequest(const ChatRequest& from);

  inline ChatRequest& operator=(const ChatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChatRequest(ChatRequest&& from) noexcept
    : ChatRequest() {
    *this = ::std::move(from);
  }

  inline ChatRequest& operator=(ChatRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChatRequest* internal_default_instance() {
    return reinterpret_cast<const ChatRequest*>(
               &_ChatRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ChatRequest* other);
  friend void swap(ChatRequest& a, ChatRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChatRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ChatRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChatRequest& from);
  void MergeFrom(const ChatRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChatRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string chatmessage = 2;
  void clear_chatmessage();
  static const int kChatmessageFieldNumber = 2;
  const ::std::string& chatmessage() const;
  void set_chatmessage(const ::std::string& value);
  #if LANG_CXX11
  void set_chatmessage(::std::string&& value);
  #endif
  void set_chatmessage(const char* value);
  void set_chatmessage(const char* value, size_t size);
  ::std::string* mutable_chatmessage();
  ::std::string* release_chatmessage();
  void set_allocated_chatmessage(::std::string* chatmessage);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:WZRY.ChatRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr chatmessage_;
  ::google::protobuf::int32 id_;
  mutable int _cached_size_;
  friend struct ::protobuf_WZRYMessageProto_2eproto::TableStruct;
  friend void ::protobuf_WZRYMessageProto_2eproto::InitDefaultsChatRequestImpl();
};
// -------------------------------------------------------------------

class ChatResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WZRY.ChatResponse) */ {
 public:
  ChatResponse();
  virtual ~ChatResponse();

  ChatResponse(const ChatResponse& from);

  inline ChatResponse& operator=(const ChatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChatResponse(ChatResponse&& from) noexcept
    : ChatResponse() {
    *this = ::std::move(from);
  }

  inline ChatResponse& operator=(ChatResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChatResponse* internal_default_instance() {
    return reinterpret_cast<const ChatResponse*>(
               &_ChatResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(ChatResponse* other);
  friend void swap(ChatResponse& a, ChatResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChatResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ChatResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChatResponse& from);
  void MergeFrom(const ChatResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChatResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string chatmessage = 2;
  void clear_chatmessage();
  static const int kChatmessageFieldNumber = 2;
  const ::std::string& chatmessage() const;
  void set_chatmessage(const ::std::string& value);
  #if LANG_CXX11
  void set_chatmessage(::std::string&& value);
  #endif
  void set_chatmessage(const char* value);
  void set_chatmessage(const char* value, size_t size);
  ::std::string* mutable_chatmessage();
  ::std::string* release_chatmessage();
  void set_allocated_chatmessage(::std::string* chatmessage);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:WZRY.ChatResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr chatmessage_;
  ::google::protobuf::int32 id_;
  mutable int _cached_size_;
  friend struct ::protobuf_WZRYMessageProto_2eproto::TableStruct;
  friend void ::protobuf_WZRYMessageProto_2eproto::InitDefaultsChatResponseImpl();
};
// -------------------------------------------------------------------

class SkillRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WZRY.SkillRequest) */ {
 public:
  SkillRequest();
  virtual ~SkillRequest();

  SkillRequest(const SkillRequest& from);

  inline SkillRequest& operator=(const SkillRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SkillRequest(SkillRequest&& from) noexcept
    : SkillRequest() {
    *this = ::std::move(from);
  }

  inline SkillRequest& operator=(SkillRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SkillRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SkillRequest* internal_default_instance() {
    return reinterpret_cast<const SkillRequest*>(
               &_SkillRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(SkillRequest* other);
  friend void swap(SkillRequest& a, SkillRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SkillRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SkillRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SkillRequest& from);
  void MergeFrom(const SkillRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SkillRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 skillid = 2;
  void clear_skillid();
  static const int kSkillidFieldNumber = 2;
  ::google::protobuf::int32 skillid() const;
  void set_skillid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:WZRY.SkillRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 skillid_;
  mutable int _cached_size_;
  friend struct ::protobuf_WZRYMessageProto_2eproto::TableStruct;
  friend void ::protobuf_WZRYMessageProto_2eproto::InitDefaultsSkillRequestImpl();
};
// -------------------------------------------------------------------

class SkillResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WZRY.SkillResponse) */ {
 public:
  SkillResponse();
  virtual ~SkillResponse();

  SkillResponse(const SkillResponse& from);

  inline SkillResponse& operator=(const SkillResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SkillResponse(SkillResponse&& from) noexcept
    : SkillResponse() {
    *this = ::std::move(from);
  }

  inline SkillResponse& operator=(SkillResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SkillResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SkillResponse* internal_default_instance() {
    return reinterpret_cast<const SkillResponse*>(
               &_SkillResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(SkillResponse* other);
  friend void swap(SkillResponse& a, SkillResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SkillResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  SkillResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SkillResponse& from);
  void MergeFrom(const SkillResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SkillResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 skillid = 2;
  void clear_skillid();
  static const int kSkillidFieldNumber = 2;
  ::google::protobuf::int32 skillid() const;
  void set_skillid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:WZRY.SkillResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 skillid_;
  mutable int _cached_size_;
  friend struct ::protobuf_WZRYMessageProto_2eproto::TableStruct;
  friend void ::protobuf_WZRYMessageProto_2eproto::InitDefaultsSkillResponseImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CloseRequest

// -------------------------------------------------------------------

// LoginRequest

// bool islogin = 1;
inline void LoginRequest::clear_islogin() {
  islogin_ = false;
}
inline bool LoginRequest::islogin() const {
  // @@protoc_insertion_point(field_get:WZRY.LoginRequest.islogin)
  return islogin_;
}
inline void LoginRequest::set_islogin(bool value) {
  
  islogin_ = value;
  // @@protoc_insertion_point(field_set:WZRY.LoginRequest.islogin)
}

// string username = 2;
inline void LoginRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::username() const {
  // @@protoc_insertion_point(field_get:WZRY.LoginRequest.username)
  return username_.GetNoArena();
}
inline void LoginRequest::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:WZRY.LoginRequest.username)
}
#if LANG_CXX11
inline void LoginRequest::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:WZRY.LoginRequest.username)
}
#endif
inline void LoginRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:WZRY.LoginRequest.username)
}
inline void LoginRequest::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:WZRY.LoginRequest.username)
}
inline ::std::string* LoginRequest::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:WZRY.LoginRequest.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_username() {
  // @@protoc_insertion_point(field_release:WZRY.LoginRequest.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:WZRY.LoginRequest.username)
}

// string passwd = 3;
inline void LoginRequest::clear_passwd() {
  passwd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::passwd() const {
  // @@protoc_insertion_point(field_get:WZRY.LoginRequest.passwd)
  return passwd_.GetNoArena();
}
inline void LoginRequest::set_passwd(const ::std::string& value) {
  
  passwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:WZRY.LoginRequest.passwd)
}
#if LANG_CXX11
inline void LoginRequest::set_passwd(::std::string&& value) {
  
  passwd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:WZRY.LoginRequest.passwd)
}
#endif
inline void LoginRequest::set_passwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  passwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:WZRY.LoginRequest.passwd)
}
inline void LoginRequest::set_passwd(const char* value, size_t size) {
  
  passwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:WZRY.LoginRequest.passwd)
}
inline ::std::string* LoginRequest::mutable_passwd() {
  
  // @@protoc_insertion_point(field_mutable:WZRY.LoginRequest.passwd)
  return passwd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_passwd() {
  // @@protoc_insertion_point(field_release:WZRY.LoginRequest.passwd)
  
  return passwd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_passwd(::std::string* passwd) {
  if (passwd != NULL) {
    
  } else {
    
  }
  passwd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), passwd);
  // @@protoc_insertion_point(field_set_allocated:WZRY.LoginRequest.passwd)
}

// -------------------------------------------------------------------

// LoginResponse

// bool issuccess = 1;
inline void LoginResponse::clear_issuccess() {
  issuccess_ = false;
}
inline bool LoginResponse::issuccess() const {
  // @@protoc_insertion_point(field_get:WZRY.LoginResponse.issuccess)
  return issuccess_;
}
inline void LoginResponse::set_issuccess(bool value) {
  
  issuccess_ = value;
  // @@protoc_insertion_point(field_set:WZRY.LoginResponse.issuccess)
}

// string message = 2;
inline void LoginResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginResponse::message() const {
  // @@protoc_insertion_point(field_get:WZRY.LoginResponse.message)
  return message_.GetNoArena();
}
inline void LoginResponse::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:WZRY.LoginResponse.message)
}
#if LANG_CXX11
inline void LoginResponse::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:WZRY.LoginResponse.message)
}
#endif
inline void LoginResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:WZRY.LoginResponse.message)
}
inline void LoginResponse::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:WZRY.LoginResponse.message)
}
inline ::std::string* LoginResponse::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:WZRY.LoginResponse.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginResponse::release_message() {
  // @@protoc_insertion_point(field_release:WZRY.LoginResponse.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResponse::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:WZRY.LoginResponse.message)
}

// -------------------------------------------------------------------

// RegisterRequest

// string newusername = 1;
inline void RegisterRequest::clear_newusername() {
  newusername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterRequest::newusername() const {
  // @@protoc_insertion_point(field_get:WZRY.RegisterRequest.newusername)
  return newusername_.GetNoArena();
}
inline void RegisterRequest::set_newusername(const ::std::string& value) {
  
  newusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:WZRY.RegisterRequest.newusername)
}
#if LANG_CXX11
inline void RegisterRequest::set_newusername(::std::string&& value) {
  
  newusername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:WZRY.RegisterRequest.newusername)
}
#endif
inline void RegisterRequest::set_newusername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  newusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:WZRY.RegisterRequest.newusername)
}
inline void RegisterRequest::set_newusername(const char* value, size_t size) {
  
  newusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:WZRY.RegisterRequest.newusername)
}
inline ::std::string* RegisterRequest::mutable_newusername() {
  
  // @@protoc_insertion_point(field_mutable:WZRY.RegisterRequest.newusername)
  return newusername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequest::release_newusername() {
  // @@protoc_insertion_point(field_release:WZRY.RegisterRequest.newusername)
  
  return newusername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_allocated_newusername(::std::string* newusername) {
  if (newusername != NULL) {
    
  } else {
    
  }
  newusername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), newusername);
  // @@protoc_insertion_point(field_set_allocated:WZRY.RegisterRequest.newusername)
}

// string newpasswd = 2;
inline void RegisterRequest::clear_newpasswd() {
  newpasswd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterRequest::newpasswd() const {
  // @@protoc_insertion_point(field_get:WZRY.RegisterRequest.newpasswd)
  return newpasswd_.GetNoArena();
}
inline void RegisterRequest::set_newpasswd(const ::std::string& value) {
  
  newpasswd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:WZRY.RegisterRequest.newpasswd)
}
#if LANG_CXX11
inline void RegisterRequest::set_newpasswd(::std::string&& value) {
  
  newpasswd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:WZRY.RegisterRequest.newpasswd)
}
#endif
inline void RegisterRequest::set_newpasswd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  newpasswd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:WZRY.RegisterRequest.newpasswd)
}
inline void RegisterRequest::set_newpasswd(const char* value, size_t size) {
  
  newpasswd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:WZRY.RegisterRequest.newpasswd)
}
inline ::std::string* RegisterRequest::mutable_newpasswd() {
  
  // @@protoc_insertion_point(field_mutable:WZRY.RegisterRequest.newpasswd)
  return newpasswd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequest::release_newpasswd() {
  // @@protoc_insertion_point(field_release:WZRY.RegisterRequest.newpasswd)
  
  return newpasswd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_allocated_newpasswd(::std::string* newpasswd) {
  if (newpasswd != NULL) {
    
  } else {
    
  }
  newpasswd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), newpasswd);
  // @@protoc_insertion_point(field_set_allocated:WZRY.RegisterRequest.newpasswd)
}

// -------------------------------------------------------------------

// RegisterResponse

// bool issuccess = 1;
inline void RegisterResponse::clear_issuccess() {
  issuccess_ = false;
}
inline bool RegisterResponse::issuccess() const {
  // @@protoc_insertion_point(field_get:WZRY.RegisterResponse.issuccess)
  return issuccess_;
}
inline void RegisterResponse::set_issuccess(bool value) {
  
  issuccess_ = value;
  // @@protoc_insertion_point(field_set:WZRY.RegisterResponse.issuccess)
}

// string message = 2;
inline void RegisterResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterResponse::message() const {
  // @@protoc_insertion_point(field_get:WZRY.RegisterResponse.message)
  return message_.GetNoArena();
}
inline void RegisterResponse::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:WZRY.RegisterResponse.message)
}
#if LANG_CXX11
inline void RegisterResponse::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:WZRY.RegisterResponse.message)
}
#endif
inline void RegisterResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:WZRY.RegisterResponse.message)
}
inline void RegisterResponse::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:WZRY.RegisterResponse.message)
}
inline ::std::string* RegisterResponse::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:WZRY.RegisterResponse.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterResponse::release_message() {
  // @@protoc_insertion_point(field_release:WZRY.RegisterResponse.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterResponse::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:WZRY.RegisterResponse.message)
}

// -------------------------------------------------------------------

// MatchRequest

// bool ismatch = 1;
inline void MatchRequest::clear_ismatch() {
  ismatch_ = false;
}
inline bool MatchRequest::ismatch() const {
  // @@protoc_insertion_point(field_get:WZRY.MatchRequest.ismatch)
  return ismatch_;
}
inline void MatchRequest::set_ismatch(bool value) {
  
  ismatch_ = value;
  // @@protoc_insertion_point(field_set:WZRY.MatchRequest.ismatch)
}

// int32 matchtype = 2;
inline void MatchRequest::clear_matchtype() {
  matchtype_ = 0;
}
inline ::google::protobuf::int32 MatchRequest::matchtype() const {
  // @@protoc_insertion_point(field_get:WZRY.MatchRequest.matchtype)
  return matchtype_;
}
inline void MatchRequest::set_matchtype(::google::protobuf::int32 value) {
  
  matchtype_ = value;
  // @@protoc_insertion_point(field_set:WZRY.MatchRequest.matchtype)
}

// -------------------------------------------------------------------

// MatchResponse

// bool issuccess = 1;
inline void MatchResponse::clear_issuccess() {
  issuccess_ = false;
}
inline bool MatchResponse::issuccess() const {
  // @@protoc_insertion_point(field_get:WZRY.MatchResponse.issuccess)
  return issuccess_;
}
inline void MatchResponse::set_issuccess(bool value) {
  
  issuccess_ = value;
  // @@protoc_insertion_point(field_set:WZRY.MatchResponse.issuccess)
}

// string matchmessage = 2;
inline void MatchResponse::clear_matchmessage() {
  matchmessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchResponse::matchmessage() const {
  // @@protoc_insertion_point(field_get:WZRY.MatchResponse.matchmessage)
  return matchmessage_.GetNoArena();
}
inline void MatchResponse::set_matchmessage(const ::std::string& value) {
  
  matchmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:WZRY.MatchResponse.matchmessage)
}
#if LANG_CXX11
inline void MatchResponse::set_matchmessage(::std::string&& value) {
  
  matchmessage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:WZRY.MatchResponse.matchmessage)
}
#endif
inline void MatchResponse::set_matchmessage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  matchmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:WZRY.MatchResponse.matchmessage)
}
inline void MatchResponse::set_matchmessage(const char* value, size_t size) {
  
  matchmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:WZRY.MatchResponse.matchmessage)
}
inline ::std::string* MatchResponse::mutable_matchmessage() {
  
  // @@protoc_insertion_point(field_mutable:WZRY.MatchResponse.matchmessage)
  return matchmessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchResponse::release_matchmessage() {
  // @@protoc_insertion_point(field_release:WZRY.MatchResponse.matchmessage)
  
  return matchmessage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchResponse::set_allocated_matchmessage(::std::string* matchmessage) {
  if (matchmessage != NULL) {
    
  } else {
    
  }
  matchmessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), matchmessage);
  // @@protoc_insertion_point(field_set_allocated:WZRY.MatchResponse.matchmessage)
}

// -------------------------------------------------------------------

// ChatRequest

// int32 id = 1;
inline void ChatRequest::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 ChatRequest::id() const {
  // @@protoc_insertion_point(field_get:WZRY.ChatRequest.id)
  return id_;
}
inline void ChatRequest::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:WZRY.ChatRequest.id)
}

// string chatmessage = 2;
inline void ChatRequest::clear_chatmessage() {
  chatmessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChatRequest::chatmessage() const {
  // @@protoc_insertion_point(field_get:WZRY.ChatRequest.chatmessage)
  return chatmessage_.GetNoArena();
}
inline void ChatRequest::set_chatmessage(const ::std::string& value) {
  
  chatmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:WZRY.ChatRequest.chatmessage)
}
#if LANG_CXX11
inline void ChatRequest::set_chatmessage(::std::string&& value) {
  
  chatmessage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:WZRY.ChatRequest.chatmessage)
}
#endif
inline void ChatRequest::set_chatmessage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  chatmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:WZRY.ChatRequest.chatmessage)
}
inline void ChatRequest::set_chatmessage(const char* value, size_t size) {
  
  chatmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:WZRY.ChatRequest.chatmessage)
}
inline ::std::string* ChatRequest::mutable_chatmessage() {
  
  // @@protoc_insertion_point(field_mutable:WZRY.ChatRequest.chatmessage)
  return chatmessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChatRequest::release_chatmessage() {
  // @@protoc_insertion_point(field_release:WZRY.ChatRequest.chatmessage)
  
  return chatmessage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChatRequest::set_allocated_chatmessage(::std::string* chatmessage) {
  if (chatmessage != NULL) {
    
  } else {
    
  }
  chatmessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chatmessage);
  // @@protoc_insertion_point(field_set_allocated:WZRY.ChatRequest.chatmessage)
}

// -------------------------------------------------------------------

// ChatResponse

// int32 id = 1;
inline void ChatResponse::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 ChatResponse::id() const {
  // @@protoc_insertion_point(field_get:WZRY.ChatResponse.id)
  return id_;
}
inline void ChatResponse::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:WZRY.ChatResponse.id)
}

// string chatmessage = 2;
inline void ChatResponse::clear_chatmessage() {
  chatmessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChatResponse::chatmessage() const {
  // @@protoc_insertion_point(field_get:WZRY.ChatResponse.chatmessage)
  return chatmessage_.GetNoArena();
}
inline void ChatResponse::set_chatmessage(const ::std::string& value) {
  
  chatmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:WZRY.ChatResponse.chatmessage)
}
#if LANG_CXX11
inline void ChatResponse::set_chatmessage(::std::string&& value) {
  
  chatmessage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:WZRY.ChatResponse.chatmessage)
}
#endif
inline void ChatResponse::set_chatmessage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  chatmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:WZRY.ChatResponse.chatmessage)
}
inline void ChatResponse::set_chatmessage(const char* value, size_t size) {
  
  chatmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:WZRY.ChatResponse.chatmessage)
}
inline ::std::string* ChatResponse::mutable_chatmessage() {
  
  // @@protoc_insertion_point(field_mutable:WZRY.ChatResponse.chatmessage)
  return chatmessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChatResponse::release_chatmessage() {
  // @@protoc_insertion_point(field_release:WZRY.ChatResponse.chatmessage)
  
  return chatmessage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChatResponse::set_allocated_chatmessage(::std::string* chatmessage) {
  if (chatmessage != NULL) {
    
  } else {
    
  }
  chatmessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chatmessage);
  // @@protoc_insertion_point(field_set_allocated:WZRY.ChatResponse.chatmessage)
}

// -------------------------------------------------------------------

// SkillRequest

// int32 id = 1;
inline void SkillRequest::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 SkillRequest::id() const {
  // @@protoc_insertion_point(field_get:WZRY.SkillRequest.id)
  return id_;
}
inline void SkillRequest::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:WZRY.SkillRequest.id)
}

// int32 skillid = 2;
inline void SkillRequest::clear_skillid() {
  skillid_ = 0;
}
inline ::google::protobuf::int32 SkillRequest::skillid() const {
  // @@protoc_insertion_point(field_get:WZRY.SkillRequest.skillid)
  return skillid_;
}
inline void SkillRequest::set_skillid(::google::protobuf::int32 value) {
  
  skillid_ = value;
  // @@protoc_insertion_point(field_set:WZRY.SkillRequest.skillid)
}

// -------------------------------------------------------------------

// SkillResponse

// int32 id = 1;
inline void SkillResponse::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 SkillResponse::id() const {
  // @@protoc_insertion_point(field_get:WZRY.SkillResponse.id)
  return id_;
}
inline void SkillResponse::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:WZRY.SkillResponse.id)
}

// int32 skillid = 2;
inline void SkillResponse::clear_skillid() {
  skillid_ = 0;
}
inline ::google::protobuf::int32 SkillResponse::skillid() const {
  // @@protoc_insertion_point(field_get:WZRY.SkillResponse.skillid)
  return skillid_;
}
inline void SkillResponse::set_skillid(::google::protobuf::int32 value) {
  
  skillid_ = value;
  // @@protoc_insertion_point(field_set:WZRY.SkillResponse.skillid)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace WZRY

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_WZRYMessageProto_2eproto__INCLUDED
